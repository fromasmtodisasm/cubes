
Sunday April 12th, 2015
-----------------------

    Big initial hitch when the game starts. 

    Unfortunately, this may mean that we're CPU bound when all cubes are moving.

    Find out!

    Confirmed. This is actually bad news. It means we're CPU bound on the physics.

    Maybe Rubikon will be better...

    Cube blow seems to be pulling cube *down* towards floor? Why?

    Cause caused by cube blow origin being set to same position as the player cube, instead
    of being the projection of the player cube position onto the z=0 plane.

    Bring back linear drag. Required to slow the cube in the air while hovering.

    Linear drag is not applying because I'm not pushing back the object state
    from the cube entities to the simulation before physics update.

    Implement pre-physics update for cubes.

    Fixed a bunch of errors where initial entity state was not correctly setup.

    Remove scale from physics state. It's not part of physics state, it's part of physics init for object only.

    Now tune the player cube drag.

    Fixed by reducing player iterations down to 16. Was 64. 

    Figure there are enough ticks between render steps that less iterations per-tick are acceptable.

    Disable everything except the cube blow lift.

    Retune the jump and hover forces and drag. It's a bit draggy right now. Needs less drag. More spring.

    Got it basically back into the right area. Could probably use more fine tuning later.

    Getting some penetration with the player cube and the ground.

    May need to cosmetically enhance this, eg. if player cube center is below minimum z, clamp it.

    Fixed by making small adjustment to CFM


Saturday April 11th, 2015
-------------------------

    Setup the client so it also creates a world and updates it with ticks.

    Added code to get input on client using direct key state accessors.

    Doesn't seem that player cube entity is getting picked up by the entity manager,
    or at least, it isn't valid on get entity return?

    Validate cubes get added properly at entity level on setup?

    Was missing the set entity, plus some bugs in the entity allocate.

    Works now.

    Verified that input is getting properly sampled.

    Add code to physics manager to grab state from physics objects and update cube entities.

    Implement code to grab the render state from cube entities.

    Renamed RenderCubes to RenderState, it's now more generic. We could render more than cubes.

    Bunch of work converting over.

    Added render_get_state which takes a world struct. Generic.

    Actually instance the render object inside client.

    Bring across camera smoothing etc.

    Hook up basically minimal rendering code.

    It should in theory be rendering now but it's not. Why not?

    Not sure what is going on. Shader problems?

    Nope. Problems with render not having display width/height set up correctly.

    Cubes are now rendering in a strange way, but at least I'm seeing something.

    Why are cubes rendering like this? Seems like the rotation might be off -- x,y,z,w wrong order?

    Was just missing initialization for cube orientation, lin/ang vel.

    Also seems like the floor is not added properly in the simulation?

    Fixed. Added plane for floor.

    Adjusted drag so it's less strong. Was too much @ 240HZ.

    Seeing random stuff that looks like the delta time for frames is way off. eg. fast/slow.

    Some tuning of physics parameters, drag etc.


Thursday April 9th, 2015
------------------------

    Hook up the simulation so it runs on the server.

    Setup server ticks so we get 240HZ ticks on server running through simulation

    Move the simulation and entities code into shared, "World", eg. world struct

    Everything works from world struct. Don't have globals. Don't make this mistake.

    Make all code for setting up the world and pumping it shared in world.h


Tuesday April 7th, 2015
-----------------------

    Cleaned up the C++ bullshit in shader loading code


Sunday April 5th, 2015
----------------------

    Bring across the rest of the cube render into render.cpp

    Most brought across. 

    Convert the last glm::ortho to vectorial to remove that POS library.


Saturday March 28th, 2015
-------------------------

    Sketch out initial render.h

    Plan out what to bring across

    Seems that at minimum I really only need the load shader, unload shader.

    Don't really need the manager.


Friday March 27th, 2015
-----------------------

    Hook up player velocity tilt.

    Hook up player push bobbing etc.

    Hook up player push/pull on other cubes entities in the world.

    Game logic for processing player inputs and controlling the sim is now ported across.


Thursday March 26th, 2015
-------------------------

    Brought across update authority into entity.cpp (commented out)

    Bring across the game code into game.h. This is the code that takes player input and applies
    forces and so on to cubes. Structure this such that it is easily called within the context
    of client side prediction rollback.

    Ensure that game code doesn't talk to ODE directly. goes through physics.h

    Stopped work on this as more physics sim work needs to be done first.

    Extended base entity to have a physics index.

    Extended cube entity create to actually create a physics object and set "physics_index" in the object.

    Renamed base entity "index" to "entity_index" to avoid confusion.

    Extended physics update to accept tick #

    Can now continue with player input application...

    Hook up player strafe forces.

    Hook up player bobbing force and torque.


Wednesday March 25th, 2015
--------------------------

    Set up physics.h and physics manager. This is the physics data that shims to the simulation.

    For now bring across ODE, conversion to Rubikon comes later.

    Don't custom build a version of ODE it's simply not required. Use the brew version.

    Split up cpp into physics_ode.cpp so we can later on have a physics_rubikon.cpp implementation.

    Convert physics interface to use vectorial instead of shitty old math library.

    Clean up the physics interface.


Tuesday March 24th, 2015
------------------------

    Need to bring in vectorial for vec3, quat etc.

    Rename edict to entity. Entity is the name I need here. Edict is a strange influence from past projects. 

    Added entity type. Added cube type and null type.

    Setup cubes.h. 

    Each cube should then have its own cube index, and there should be a concept of "max cubes"

    Is this overkill? I don't think so. I need to be able to create cubes dynamically
    and track them separately from non-cube entities. It seems that per-entity type
    there should be a manager capable of iterating across those entities af that type
    directly, as well as owning the pool of those entities that can be allocated.

    This is the cube entity type and all related cube functionality.

    Sketch out basic functions, data structures in here. Seems reasonable.

    Setup default entity type to world.

    Since world entity is at zero and nothing special is done to set it up/load it, this works well.

    Eventually world entity should have a model, and this is the "static scene" portion of each level.

    While it should just derive from the base entity type, it will have its own manager
    "cube manager" which can strip mine cubes and provide a think per-cube if necessary.

    Actually implemented cube allocate and free. Should be functional now.

    Actually implement entity allocate.

    Hack up code to create the cube entities

    Add sequence # per-entity index.

    Implement entity free.

    Bump sequence # on entity free.


Monday March 23rd, 2015
-----------------------

    Create a simple edict like system, SoA that maps object indices to entities.

    0 is world.

    1 is player 1, etc.

    Rest of cubes are MaxPlayers.

    Work out relationship between edicts and entities.

    Are entities managed elsewhere?

    Who frees them?

    Who serializes them? :D

    I think the edict system just doesn't care. It has a type per-edict,
    and it is game codes responsibility to handle that type and serialize
    each type appropriately.

    We don't need dynamic types, eg. types not known at compile time.

    So a simple type per-edict is appropriate.

    First entity type will be cube entity.

    I think the cube manager owns the cubes, and inserts them into edict index.

    This way there is an owner, and the physics manager can have the cubes
    for fast iteration across, but also they live in the edict system and
    can be indexed as edicts with objects of other types.


Saturday March 21st, 2015
-------------------------

    Initial commit.

    Move constants into const.h

    Bring across protocol.h from compression demo

    Split out snapshot stuff from protocol.h

    Add constants to const.h for tick rate (240), server frame rate (30), client frame rate (60)

    Need to get an actual high precision timer for the server. I'm sure I have old code around there for this

    Bring across stuff for timers, sleep and so on (platform.h)

    Sketch out server loop with time and sleeps etc. Working fine.

    Sketched out a good server loop that measures jitter caused by sleep and works with it.

    Added code to detect dropped frames.

    Added safety code so that at least 50% of frame time is required to sim frame otherwise another frame is dropped.

    Setup premake for the client and server so I can link to stuff

    Bring across enough GLFW to get the display window created and updated

    Get the client main loop working

    Base it around VSYNC

    Make sure the client frame time is sampled immediately after frame swap so there is minimal variance

    Unfortunately quite a wide time variance exists... stupid non-realtime OS :p
